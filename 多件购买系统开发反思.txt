<<<<<<<<<一定要先设计 先设计 先设计。 琢磨清楚再开工>>>>>>>>>>>>

1、 整体的系统设计。 《磨刀不误砍柴工》

	1.1 数据模型设计
		1.1.1 符合关系型数据 范式设计。 不冗余。 PS: 缓存单独后续考虑; 属于优化阶段。
		
		1.1.2 数据模型属性分类
			a. 不变属性; or 较少变化的属性。
			b. 经常改变的属性; or 经常改变且读取的实时性要求高的属性, 如库存。
			c. 经常读的属性;
			d. 读写分类。
			e. 属性的大小, 如大的文本属性, 和简单的 标识 byte属性。(简单属性, 复杂属性)
			d. 数据模型属性分组, 如依据几个属性经常一起出现, 如一起修改, 一起展示。
			
		1.1.3 适当构建数据模型实体
			a. 大小适中(属性的个数 不多不少), 这样才能等到数量适中的实体类(不多不少)。
			b. 全面梳理将要实现(今后可能要实现)所有提供的服务接口。 
			c. 形成各个实体类。	
			d. 将c得到的实体类, 放回b中检查, 是否恰当。 否则依据上述步骤重新梳理一遍, 检验是否存在更优的设计。
			
	1.2 数据冗余问题(设计时)
		1.2.1 尽量不要冗余, 冗余就存在数据不一致的风险。
		1.2.2 经常变化(写操作多)的数据, 最好不要冗余, 除非无更优选择(多想想,再想想)。
		1.2.3 变化(写操作多)高频的数据(如库存),不要冗余。 
			  a 除非别无选择, 一定要反反复复, 从 1.1 开始从头梳理, 寻找更优的选择, 同时考虑清楚 后果。 ( 后果自负(: )。
			  b 实在要冗余时, 先考虑利用缓存 , 等其它方式是否能够处理。 
			  c 设计时 不要冗余, 不要冗余, 不要冗余 重要的事情说三次。
		
		1.2.4 适当冗余, 对于理论上(以及对未来可能的变化的前提下), 不会变化的数据 冗余。(冗余copy副本数不易过多) 
			  同时考虑冗余所带来的收益。
			  对于 不变极少的数据。 如果冗余能够带来可观的收益。 能cover住 冗余所产生的成本。  
			  同时, 考虑清楚数据变化时, 数据同步方案。
		
		1.2.5 冗余 是 权衡 取舍 收益成本。

		
	1.3 缓存设计
		
		
		
2、 不做重复的事情 (还是冗余的问题)
	
	2.1 Don't Copy-and-Paste Code。 
		利用面向对象 设计模式 封装代码
	
	2.2 工具类(日常积累)
		如 代码生成小工具,  
		1 controller, service, dao, CRUD的自动生成。
		2 数据库表字段 , 与实体类 , 配置文件
		  (如mybatis, 如mongodb org.bson.Document, 实体类 互相转换)代码的自动生成。
		3 如果有页面 页面表单 实体类 代码的自动生成。
		4 一个类的填充 如A a = new A(); a.set... 自动生成每个字段的set代码。 
		5 两个类 A B a.setA1(b.getB1()) 代码的自动生成工具类。
		6 单元测试 接口自动生成 P p = new (); p.setP1("....") 留着填写实际值空白

	
3、工具积累
	
  